package celtech.roboxbase.configuration.slicer;

import celtech.roboxbase.BaseLookup;
import celtech.roboxbase.configuration.BaseConfiguration;
import celtech.roboxbase.configuration.SlicerType;
import celtech.roboxbase.configuration.fileRepresentation.SlicerMappingData;
import celtech.roboxbase.configuration.fileRepresentation.SlicerParametersFile;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import libertysystems.stenographer.Stenographer;
import libertysystems.stenographer.StenographerFactory;

/**
 *
 * @author Ian
 */
public abstract class SlicerConfigWriter
{

    private final Stenographer steno = StenographerFactory.getStenographer(
        Slic3rConfigWriter.class.getName());
    SlicerType slicerType = null;
    private SimpleDateFormat dateFormatter = null;
    protected NumberFormat threeDPformatter;

    private float centreX = 0;
    private float centreY = 0;

    private final String parameterDivider = ":";
    private final String queryDivider = "?";
    private final String optionalDivider = "->";
    private final String equivalenceDivider = "=";

    private final String optionalNoOutput = "-|";

    public SlicerConfigWriter()
    {
        dateFormatter = new SimpleDateFormat("EEE d MMM y HH:mm:ss", Locale.UK);
        threeDPformatter = DecimalFormat.getNumberInstance(Locale.UK);
        threeDPformatter.setMaximumFractionDigits(3);
        threeDPformatter.setGroupingUsed(false);
    }

    public final void generateConfigForSlicer(SlicerParametersFile profileData,
        String destinationFile)
    {
        SlicerMappingData mappingData = BaseLookup.getSlicerMappings().getMappings().get(slicerType);
        generateConfigForSlicerWithMappings(profileData, destinationFile, mappingData);
    }

    /**
     * Generates a .roboxprofile file which takes into account the user slicer preferences,
     * and the slicermappings.dat file, which will map the options for a particular slicer.
     * 
     * @param profileData the user slicer parameters.
     * @param destinationFile the destination for the .roboxprofile file.
     * @param mappingData The mapping data from the slicermappings.dat file.
     */
    public final void generateConfigForSlicerWithMappings(SlicerParametersFile profileData,
        String destinationFile, SlicerMappingData mappingData)
    {

        bringDataInBounds(profileData);

        File outputFile = new File(destinationFile);
        FileWriter writer = null;

        try
        {
            writer = new FileWriter(outputFile);

            String dateString = dateFormatter.format(new Date());
            writer.write("#Slicer configuration generated by AutoMaker on " + dateString + "\n");
            writer.write(
                "#"
                + BaseConfiguration.getApplicationName()
                + " version "
                + BaseConfiguration.getApplicationVersion()
                + "\n");
            writer.write("#Slicer type " + slicerType.name() + "\n");
            writer.write("#Profile " + profileData.getProfileName() + "\n");
            writer.write("#\n");

            outputFilamentDiameter(writer,
                                   BaseConfiguration.filamentDiameterToYieldVolumetricExtrusion);

            outputPrintCentre(writer, centreX, centreY);

            //Process the defaults
            for (String defaultData : mappingData.getDefaults())
            {
                // This is a default value for the slicer - don't look it up.
                String[] valueElements = defaultData.split(":");
                String variableName = valueElements[0];

                String value = "";
                if (valueElements.length == 2)
                {
                    value = valueElements[1];
                }

                steno.debug("Writing default " + variableName);
                outputLine(writer, variableName, value);
            }

            for (Map.Entry<String, String> entry : mappingData.getMappingData().entrySet())
            {
//                String methodName = entry.getKey();
//                String targetVariableName = extractTargetVariableName(entry.getValue());
                String targetVariableName = entry.getKey();
                String methodNameOrValue = extractTargetVariableName(entry.getValue());
                steno.debug("Processing method: " + methodNameOrValue + " and variable : "
                    + targetVariableName);

                try
                {
                    float value = Float.parseFloat(methodNameOrValue);
                    Optional<Float> calculatedValue = applyValue(profileData, value,
                                                                 entry.getValue());
                    if (calculatedValue.isPresent())
                    {
                        outputLine(writer, targetVariableName,
                                   calculatedValue.get().intValue());
                    }
                } catch (NumberFormatException nfe)
                {
                    // it's a method name

                    Method getMethod;

                    try
                    {
                        getMethod = getVariableMethod(methodNameOrValue);

                        try
                        {
                            steno.debug("Writing " + methodNameOrValue + " : " + targetVariableName);

                            Class<?> returnTypeClass = getMethod.getReturnType();

                            if (returnTypeClass.equals(boolean.class))
                            {
                                boolean value = (boolean) getMethod.invoke(profileData);
                                outputLine(writer, targetVariableName, value);
                            } else if (returnTypeClass.equals(int.class))
                            {
                                int value = (int) getMethod.invoke(profileData);
                                Optional<Float> calculatedValue = applyValue(profileData, value,
                                                                             entry.getValue());
                                if (calculatedValue.isPresent())
                                {
                                    outputLine(writer, targetVariableName,
                                               calculatedValue.get().intValue());
                                }
                            } else if (returnTypeClass.equals(float.class))
                            {
                                float value = (float) getMethod.invoke(profileData);
                                Optional<Float> calculatedValue = applyValue(profileData, value,
                                                                             entry.getValue());
                                if (calculatedValue.isPresent())
                                {
                                    outputLine(writer, targetVariableName, calculatedValue.get());
                                }
                            } else if (returnTypeClass.equals(String.class))
                            {
                                String value = (String) getMethod.invoke(profileData);
                                outputLine(writer, targetVariableName, value);
                            } else if (returnTypeClass.equals(SlicerType.class))
                            {
                                SlicerType value = (SlicerType) getMethod.invoke(profileData);
                                outputLine(writer, targetVariableName, value);
                            } else if (returnTypeClass.equals(FillPattern.class))
                            {
                                FillPattern value = (FillPattern) getMethod.invoke(profileData);
                                outputLine(writer, targetVariableName, value);
                            } else if (returnTypeClass.equals(HashMap.class))
                            {
                                HashMap<Object, Object> map = (HashMap) getMethod.invoke(profileData);
                                if(map.containsKey(getSlicerType())) {
                                    SupportPattern value = (SupportPattern) map.get(getSlicerType());
                                    outputLine(writer, targetVariableName, value);
                                }
                            } else
                            {
                                steno.error("Got unknown return type: " + returnTypeClass.getName());
                            }

                        } catch (IllegalAccessException ex)
                        {
                            steno.error("Illegal access exception when retrieving from "
                                + methodNameOrValue);
                        } catch (InvocationTargetException ex)
                        {
                            steno.error("Invocation target exception when retrieving from "
                                + methodNameOrValue);
                        }
                    } catch (NoSuchMethodException ex)
                    {
                        steno.warning("Failed to get method: " + methodNameOrValue + " variable: "
                            + targetVariableName);
                    }
                }
            }
        } catch (FileNotFoundException ex)
        {
            steno.error("Couldn't open slicer settings file for writing - " + destinationFile
                + " : " + ex.getMessage());
        } catch (IOException ex)
        {
            steno.error("IO Exception whilst writing slic3r settings - " + destinationFile + " : "
                + ex.getMessage());
        } finally
        {
            if (writer != null)
            {
                try
                {
                    writer.close();
                } catch (IOException ex)
                {
                    steno.error("Failed to close configuration file " + outputFile.getName());
                }
            }
        }
    }

    /**
     *
     * @param x
     * @param y
     */
    public void setPrintCentre(float x, float y)
    {
        centreX = x;
        centreY = y;
    }

    protected abstract void outputLine(FileWriter writer, String variableName, boolean value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, int value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, float value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, String value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, SlicerType value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, FillPattern value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, SupportPattern value) throws IOException;

    protected abstract void outputPrintCentre(FileWriter writer, float centreX, float centreY) throws IOException;

    protected abstract void outputFilamentDiameter(FileWriter writer, float diameter) throws IOException;

    /**
     * Evaluates an operation given by a particular mapping and manipulates the 
     * profileData value based on the operation.
     * 
     * @param profileData the user slicer parameters.
     * @param value the value in the parameters file.
     * @param operationString the operation to be applied to the value.
     * @return the new value after an operation has been applied/
     */
    private Optional<Float> applyValue(SlicerParametersFile profileData, float value,
        String operationString)
    {
        float resultingValue = value;
        boolean okToProcess = false;

        if (operationString.contains(parameterDivider))
        {
            String[] valueElements = operationString.split(parameterDivider);

            boolean doneProcessing = false;

            if (valueElements.length > 1)
            {
                for (int elementCounter = 1; elementCounter < valueElements.length; elementCounter++)
                {
                    boolean optionalOperatorDetected = false;

                    String operation = valueElements[elementCounter];
                    String operator = operation.substring(0, 1);
                    String variable = operation.substring(1);

                    if (operation.contains(queryDivider))
                    {
                        String[] optionalAssignmentString = operation.substring(1).split(
                            optionalDivider);
                        if (optionalAssignmentString.length == 2)
                        {
                            optionalOperatorDetected = true;
                            if (optionalAssignmentString[0].contains(equivalenceDivider))
                            {
                                String[] optionalCheckParts = optionalAssignmentString[0].split(
                                    equivalenceDivider);

                                if (optionalCheckParts.length == 2)
                                {
                                    try
                                    {
                                        Method getMethod = getVariableMethod(optionalCheckParts[0]);

                                        Class<?> returnTypeClass = getMethod.getReturnType();

                                        if (returnTypeClass.equals(boolean.class))
                                        {
                                            try
                                            {
                                                boolean valueToTest = (boolean) getMethod.invoke(
                                                    profileData);
                                                boolean valueWeAreLookingFor = Boolean.valueOf(
                                                    optionalCheckParts[1]);
                                                boolean stopOnEquality = optionalAssignmentString[1].equals(
                                                    "|");

                                                if (valueToTest == valueWeAreLookingFor)
                                                {
                                                    if (stopOnEquality)
                                                    {
                                                        return Optional.empty();
                                                    } else
                                                    {
                                                        float valueToSet = Float.valueOf(
                                                            optionalAssignmentString[1]);
                                                        resultingValue = valueToSet;
                                                        doneProcessing = true;
                                                    }
                                                } else
                                                {
                                                    variable = valueElements[0];
                                                }
                                            } catch (IllegalAccessException | InvocationTargetException ex)
                                            {
                                                steno.error(
                                                    "Error retrieving test for value from variable "
                                                    + optionalCheckParts[0]);
                                            } catch (NumberFormatException ex)
                                            {
                                                steno.error("Error processing numeric value for "
                                                    + optionalCheckParts[1]);
                                            }
                                        } else
                                        {
                                            steno.error("I don't support return types of "
                                                + returnTypeClass.getName() + " at this time");
                                        }
                                    } catch (NoSuchMethodException ex)
                                    {
                                        steno.warning("Failed to get method for "
                                            + optionalCheckParts[0] + " in " + operationString);
                                    }
                                }
                            } else
                            {
                                try
                                {
                                    float valueToCheckFor = Float.valueOf(
                                        optionalAssignmentString[0]);
                                    float optionalAssignmentValue = Float.valueOf(
                                        optionalAssignmentString[1]);

                                    if (value == valueToCheckFor)
                                    {
                                        resultingValue = optionalAssignmentValue;
                                        doneProcessing = true;
                                    }
                                } catch (NumberFormatException ex)
                                {
                                    // Failed to process...
                                    steno.warning("Couldn't process optional slicer mapping: "
                                        + operation);
                                }
                            }
                        } else
                        {
                            steno.warning("Erroneous optional slicer mapping: " + operation);
                        }
                    }

                    if (!doneProcessing && !optionalOperatorDetected)
                    {

                        Method getMethod;

                        float variableValue = 0;

                        try
                        {
                            getMethod = getVariableMethod(variable);

                            // Found a get - must be a variable that we can use...
                            try
                            {
                                if (getMethod.getReturnType().equals(int.class))
                                {
                                    variableValue = (int) getMethod.invoke(profileData);
                                } else
                                {
                                    variableValue = (float) getMethod.invoke(profileData);
                                }
                                okToProcess = true;
                            } catch (IllegalAccessException | InvocationTargetException ex)
                            {
                                steno.warning("Failed to get value for " + variable);
                            }
                        } catch (NoSuchMethodException ex)
                        {
                            // We should have a number instead
                            try
                            {
                                variableValue = Float.valueOf(variable);
                                okToProcess = true;
                            } catch (NumberFormatException ex1)
                            {
                                steno.warning("Failed to get get method or numeric value for "
                                    + variable + " in " + operationString);
                            }
                        }

                        if (okToProcess)
                        {
                            switch (operator)
                            {
                                case "*":
                                    resultingValue = resultingValue * variableValue;
                                    break;
                                case "[":
                                    resultingValue = variableValue / resultingValue;
                                    break;
                                case "/":
                                    resultingValue = resultingValue / variableValue;
                                    break;
                                case "+":
                                    resultingValue = resultingValue + variableValue;
                                    break;
                                case "-":
                                    resultingValue = resultingValue - variableValue;
                                    break;
                            }
                        }
                    }
                }
            }
        }

        return Optional.of(resultingValue);
    }

    private String extractTargetVariableName(String value)
    {
        String targetVariableName = value;

        if (value.contains(":"))
        {
            String[] elements = value.split(":");
            targetVariableName = elements[0];
        }

        return targetVariableName;
    }

    private Method getVariableMethod(final String methodName) throws NoSuchMethodException
    {
        String altMethodName = "get" + methodName.substring(0, 1).toUpperCase()
            + methodName.substring(1, methodName.length());

        Method foundMethod = SlicerParametersFile.class.getMethod(altMethodName, null);

        return foundMethod;
    }

    abstract void bringDataInBounds(SlicerParametersFile profileData);
    
    abstract SlicerType getSlicerType();
}
